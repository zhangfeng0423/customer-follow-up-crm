## 1. 核心理念与技术栈

- **核心理念**: 性能优先，服务器端优先。严格遵循Next.js官方文档关于数据获取、渲染和路由的指引。
- **语言**: TypeScript
- **框架**: Next.js (App Router)
- **UI与样式**: Shadcn UI, Radix, Tailwind CSS (采用移动优先的响应式设计)
- **状态管理**:
    1. **URL 状态**: 页面级的、应被收藏或分享的状态（如筛选、分页、搜索词），**必须**使用 `nuqs` 存放在URL搜索参数中。
    2. **客户端全局状态**: 跨页面共享、但又不适合放在URL中的复杂状态（如购物车、当前用户信息），推荐使用 **Zustand** 进行管理。
    3. **组件本地状态**: 仅限单个组件使用的状态，**必须**使用 React 原生的 `useState` 或 `useReducer`。
- **客户端数据获取**: 
在客户端组件中需要进行**数据获取或修改**时，推荐使用 **React Query (TanStack Query)**。**必须**从Hook中解构并处理 `data`, `isLoading`, 和 `error` 三种状态。在 `isLoading` 为 `true` 时，**必须**渲染一个骨架屏 (`Skeleton`) 或加载指示器。在 `error` 存在时，**必须**渲染一个错误提示组件。
- **测试**: Vitest

## 2. 代码风格与结构

### 2.1 编程范式

- **函数式与声明式**: 推崇函数式和声明式编程模式，避免使用类组件。
- **简洁性**: 生成简洁、技术化的TypeScript代码。条件语句中应避免不必要的花括号。
- **模块化**: 鼓励迭代和模块化，避免代码重复 (DRY原则)。
- **命名**:
    - 变量名必须具有描述性 (例如 `isLoading`, `hasError`)。
    - 目录名使用小写加连字符 (kebab-case)，例如 `components/auth-wizard`。
    - 组件倾向于使用命名导出而非默认导出。

### 2.2 TypeScript 用法

- **强制使用**: 所有代码必须使用TypeScript。
- **类型定义**: 对于定义**对象**的形状，优先使用 `interface`。对于定义**联合类型、元组或需要使用类型操作符**的场景，使用 `type`。
- **枚举**: 避免使用 `enum`，推荐改用 `const assertions` 或 `Map`。
- **组件类型**: 函数式组件必须结合TypeScript接口来定义 `props`。

### 2.3 文件结构

- 文件结构应清晰，一个文件只做一件事。标准结构如下：
    - `index.ts` (导出主组件)
    - `components/` (子组件)
    - `hooks/` (自定义钩子)
    - `lib/` (辅助函数)
    - `constants/` (静态内容)
    - `types/` (类型定义)

### **2.4 组件内部结构**

为提高可读性，客户端组件文件内部的代码应遵循以下顺序：

1. `"use client"` 声明
2. 导入语句 (建议按外部库、内部绝对路径、内部相对路径分组)
3. Props 接口 (`interface`) 定义
4. 组件内部使用的类型 (`type` / `interface`) 定义
5. 常量 (`const`) 定义
6. 主组件函数 (`export function ComponentName() { ... }`)
    1. Refs (`useRef`)
    2. 状态 (`useState`, `useReducer`, `useContext`)
    3. 计算值 (`useMemo`)
    4. 事件处理函数 (`useCallback`)
    5. 副作用 (`useEffect`)
    6. JSX 返回 (`return (...)`)
7. 组件内部定义的、不依赖Props或State的工具函数

### 2.5 代码文档

所有导出的函数、组件、Hooks 和复杂的类型定义，都**必须**使用 **JSDoc** 格式添加注释。注释应清晰地描述其用途、参数 (`@param`) 和返回值 (`@returns`)。

## 3. 性能优化 (关键约定)

- **服务器组件优先 (RSC)**: 严格限制 `use client` 的使用范围。
    - **何时使用 `'use client'`**: 仅用于处理用户交互 (如 `onClick`) 或需要生命周期钩子 (如 `useEffect`) 的小型、叶子组件。
    - **禁止用于**: 数据获取、状态管理或任何可以在服务器端完成的任务。
- **Suspense**: 所有客户端组件必须用 `<Suspense>` 和一个有意义的 `fallback` UI进行包裹。
- **动态加载**: 对非首屏关键组件使用 `next/dynamic` 进行动态加载。
- **图像优化**:
    - 必须使用 `next/image` 组件而非原生 `<img>` 标签。
    - 图像应优化为 WebP 格式，包含明确的 `width` 和 `height` 属性，并实现懒加载。
- **Web Vitals**: 所有开发工作都应以优化核心Web Vitals (LCP, CLS, FID) 为目标。

## 4. API 设计与安全

- **API路由**: 在 `app/api/` 目录下创建。
- **输入验证**: 所有API路由必须使用 `Zod` 对请求体、查询参数和头部进行严格验证。
- **安全**: 绝不将敏感信息（API密钥、环境变量）硬编码在代码中。对所有用户输入进行清理，防止XSS攻击。
- **环境变量安全**：
    
    在应用启动的入口文件（例如根 `layout.tsx` 或一个专用的 `lib/env.ts` 模块）中，**必须**使用 **Zod** 来验证所有必需的环境变量 (`process.env`) 是否存在且格式正确。如果验证失败，**必须**主动抛出错误使应用在构建或启动阶段就失败，以防止在生产环境中因配置错误而导致意外行为。
    

## 5. 测试实践

- **测试框架**: 使用  Vitest。
- **测试范围**: 为所有核心业务逻辑、自定义钩子和复杂的UI组件编写单元和集成测试。
- **Mocking**: 使用 `msw` 或 `vi.mock()` 来模拟API请求和外部依赖。
- **测试命令**: `pnpm test`

## 6. 开发流程与命令

- **包管理器**: pnpm
- **启动开发**: `pnpm dev`
- **构建**: `pnpm build`
- **代码检查**: `pnpm lint`
- **格式化**: `pnpm format`

## 7. 重要补充

- 需求文件参照同文件夹下prd.md文件，严格遵守，不要自由发挥
- 数据库使用prisma
